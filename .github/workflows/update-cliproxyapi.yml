name: Update CLIProxyAPI

on:
  schedule:
    - cron: '0 8 * * *' # Runs at 08:00 UTC every day
  workflow_dispatch:

permissions:
  contents: write
  pull-requests: write

concurrency:
  group: update-cliproxyapi
  cancel-in-progress: true

jobs:
  update-cliproxyapi:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Close old unmerged bump PRs
        env:
          GH_TOKEN: ${{ secrets.AUTO_UPDATE_TOKEN }}
        run: |
          set -e
          echo "Checking for existing auto-generated bump PRs..."
          
          OLD_PRS=$(gh pr list --state open --json number,headRefName,title --jq '.[] | select(.headRefName | startswith("bump-cliproxyapi-")) | "\(.number)|\(.title)"' || true)
          
          if [ -z "$OLD_PRS" ]; then
            echo "No existing auto-generated bump PRs found."
          else
            echo "Found existing auto-generated bump PRs to close:"
            
            while IFS='|' read -r PR_NUMBER PR_TITLE; do
              if [ -n "$PR_NUMBER" ]; then
                echo "Closing PR #$PR_NUMBER: $PR_TITLE"
                gh pr close "$PR_NUMBER" --comment "Closing this PR as a newer version bump is being created." || {
                  echo "Warning: Failed to close PR #$PR_NUMBER" >&2
                }
              fi
            done <<< "$OLD_PRS"
            
            echo "✓ Closed old auto-generated bump PRs"
          fi

      - name: Get latest CLIProxyAPI release
        id: get-latest-release
        run: |
          set -e
          LATEST_JSON=$(curl -s -f https://api.github.com/repos/router-for-me/CLIProxyAPI/releases/latest)
          
          if [ -z "$LATEST_JSON" ]; then
            echo "Error: Failed to fetch latest release JSON" >&2
            exit 1
          fi

          # Ensure pure JSON by stripping potential non-printable characters if any
          LATEST_TAG=$(echo "$LATEST_JSON" | tr -d '\000-\037' | jq -r .tag_name)
          
          if [ -z "$LATEST_TAG" ] || [ "$LATEST_TAG" = "null" ]; then
            echo "Error: Failed to extract tag_name from JSON" >&2
            exit 1
          fi

          VERSION=${LATEST_TAG#v}
          
          if [ -z "$VERSION" ]; then
            echo "Error: Version string is empty" >&2
            exit 1
          fi

          echo "latest_tag=$LATEST_TAG" >> $GITHUB_OUTPUT
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Found latest version: $VERSION"

      - name: Download and Install CLIProxyAPI
        run: |
          set -e
          VERSION="${{ steps.get-latest-release.outputs.version }}"
          TAG="${{ steps.get-latest-release.outputs.latest_tag }}"
          FILENAME="CLIProxyAPI_${VERSION}_darwin_arm64.tar.gz"
          URL="https://github.com/router-for-me/CLIProxyAPI/releases/download/$TAG/$FILENAME"
          TARGET_DIR="src/Sources/Resources"
          TARGET_FILE="$TARGET_DIR/cli-proxy-api"
          
          # Create a temporary directory for extraction
          TEMP_DIR=$(mktemp -d)
          # Ensure cleanup on exit (success or failure)
          trap 'rm -rf "$TEMP_DIR"' EXIT
          echo "Using temporary directory: $TEMP_DIR"
          
          echo "Downloading $URL..."
          if ! wget -q -O "$TEMP_DIR/$FILENAME" "$URL"; then
            echo "Error: Failed to download $URL" >&2
            exit 1
          fi
          
          if [ ! -s "$TEMP_DIR/$FILENAME" ]; then
             echo "Error: Downloaded file is empty" >&2
             exit 1
          fi
          
          echo "Validating tarball..."
          if ! tar -tzf "$TEMP_DIR/$FILENAME" > /dev/null; then
             echo "Error: Invalid tarball" >&2
             exit 1
          fi
          
          echo "Extracting to temporary directory..."
          tar -xzf "$TEMP_DIR/$FILENAME" -C "$TEMP_DIR"
          
          # Find the binary file - look for files named cli-proxy-api or CLIProxyAPI
          # These are the expected binary names, not documentation or config files
          EXTRACTED_FILE=$(tar -tf "$TEMP_DIR/$FILENAME" | grep -E '^(cli-proxy-api|CLIProxyAPI)$' | head -n 1)
          
          # If not found by exact name, exclude all known non-binary files
          if [ -z "$EXTRACTED_FILE" ]; then
            EXTRACTED_FILE=$(tar -tf "$TEMP_DIR/$FILENAME" | grep -v -E '(LICENSE|README|\.md$|\.txt$|\.yaml$|\.yml$|\.json$)' | head -n 1)
          fi
          
          if [ -z "$EXTRACTED_FILE" ]; then
             echo "Error: Could not find binary in tarball" >&2
             echo "Tarball contents:" >&2
             tar -tf "$TEMP_DIR/$FILENAME" >&2
             exit 1
          fi
          
          echo "Found binary: $EXTRACTED_FILE"
          
          if [ ! -f "$TEMP_DIR/$EXTRACTED_FILE" ]; then
             echo "Error: Extraction failed, $EXTRACTED_FILE not found" >&2
             exit 1
          fi
          
          echo "Creating target directory..."
          mkdir -p "$TARGET_DIR"
          
          echo "Copying $EXTRACTED_FILE to $TARGET_FILE"
          cp "$TEMP_DIR/$EXTRACTED_FILE" "$TARGET_FILE"
          
          if [ ! -f "$TARGET_FILE" ]; then
             echo "Error: Failed to copy file to $TARGET_FILE" >&2
             exit 1
          fi
          
          if [ ! -s "$TARGET_FILE" ]; then
             echo "Error: Target file is empty" >&2
             exit 1
          fi

          chmod +x "$TARGET_FILE"
          
          echo "Verifying binary (basic checks)..."
          # Can't execute macOS ARM64 binary on Linux runner, so just verify:
          # 1. File exists and is not empty
          # 2. File size is reasonable (> 1MB for a Go binary)
          FILE_SIZE=$(stat -c%s "$TARGET_FILE" 2>/dev/null || stat -f%z "$TARGET_FILE" 2>/dev/null)
          if [ -z "$FILE_SIZE" ] || [ "$FILE_SIZE" -lt 1048576 ]; then
             echo "Error: Binary file is too small (${FILE_SIZE:-0} bytes)" >&2
             exit 1
          fi
          
          # Check file type (should be a Mach-O executable for darwin)
          if command -v file >/dev/null 2>&1; then
            FILE_TYPE=$(file "$TARGET_FILE")
            echo "File type: $FILE_TYPE"
            if ! echo "$FILE_TYPE" | grep -q -E "(Mach-O|executable)"; then
              echo "Warning: File type doesn't look like a binary executable" >&2
            fi
          fi
          
          echo "✓ Binary verification passed (${FILE_SIZE} bytes)"
          
          # Verify git status shows only the binary was modified
          echo "Git status:"
          git status --porcelain
          
          # Ensure only the binary file is changed
          CHANGED_FILES=$(git status --porcelain | grep -v "^ M src/Sources/Resources/cli-proxy-api$" || true)
          if [ -n "$CHANGED_FILES" ]; then
            echo "Error: Unexpected files were modified:" >&2
            echo "$CHANGED_FILES" >&2
            exit 1
          fi

      - name: Create Pull Request
        uses: peter-evans/create-pull-request@v6
        with:
          token: ${{ secrets.AUTO_UPDATE_TOKEN }}
          commit-message: Bump CLIProxyAPI to ${{ steps.get-latest-release.outputs.version }}
          title: Bump CLIProxyAPI to ${{ steps.get-latest-release.outputs.version }}
          body: |
            Updates bundled CLIProxyAPI to version [${{ steps.get-latest-release.outputs.version }}](https://github.com/router-for-me/CLIProxyAPI/releases/tag/${{ steps.get-latest-release.outputs.latest_tag }}).
            
            This PR was automatically generated by the Update CLIProxyAPI workflow.
          branch: bump-cliproxyapi-${{ steps.get-latest-release.outputs.version }}
          delete-branch: true
